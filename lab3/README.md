# 编译和运行方法
编译：make，运行：./server
# 整体设计
程序整体从示例所给的代码改编而来，保留了parse_request,handle_clnt函数并在其基础上改进，添加了WRITE、cache_init、handle_epoll函数以实现更多功能

parse_request函数：

它的作用是解析HTTP请求。参数包括客户端套接字、请求缓冲区和指向文件状态结构体的指针。函数首先定义了一个长度为4的字符数组，用于标识HTTP请求的结束。然后，函数通过循环读取客户端套接字中的数据，并将其存储在请求缓冲区中。在每次读取数据后，函数会检查请求缓冲区中是否包含HTTP请求的结束标识符。如果找到了结束标识符，函数将停止读取数据。如果请求缓冲区的长度超过了MAXRECV，函数将继续读取数据，直到找到结束标识符或达到MAXRECV的长度限制。接下来，函数将检查请求缓冲区中的内容是否为GET /，如果不是，则返回-2。如果是，则函数将解析请求缓冲区中的路径，并打开对应的文件。如果文件无法打开，则返回-1。如果文件打开成功，则函数将使用stat函数获取文件的状态，并检查文件是否为常规文件。如果文件不是常规文件，则返回-2。最后，函数返回文件描述符。

handle_clnt函数：

用来输出404、500、200 OK三个状态，如果是200 OK,则输出内容

WRITE函数：

在write函数上改进使其更稳定

cache_init函数：

初始化cache

handle_epoll函数：

线程函数，用于处理 epoll 事件。首先获取当前线程的ID，然后根据 ID 在 epollfdPOOL 数组中找到对应的 epollfd。接着进入一个无限循环，调用 epollwait 等待事件的发生，然后遍历所有事件，对每个事件调用 handle_clnt 函数进行处理。最后释放 events 数组的内存并返回 NULL。
# siege测试
在测试时进行了siege -c 50 -r 10 http://127.0.0.1:8000/index、siege -c 50 -t 10S http://127.0.0.1:8000/index 等多种测试
测试文件中为138个h，测试结果分别如下：

![](https://i.328888.xyz/2023/05/15/VZuhw5.png)
![](https://i.328888.xyz/2023/05/15/VZuvmH.png)

测试结果显示程序能够很好地满足需求
# 选做
## 使用线程池机制
创建MAX_THREAD_NUM个线程 pthread_ing[MAX_THREAD_NUM]以及epollfdPOOL[MAX_THREAD_NUM]来存储每个线程的epoll文件描述符，在主函数进入循环之前便创建好线程，之后在请求到达时按顺序分配给其中一个
## 使用缓存机制
对于访问过的资源，程序使用内存缓存或预取对资源读取进行加速。

在程序访问某文件时，先在cache里判断该文件之前是否被访问过，如果访问过则直接输出数据，如果未访问过，则将此次记录存入cache中
